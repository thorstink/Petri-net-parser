<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Symmetri: symmetri Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Symmetri
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">symmetri Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsymmetri_1_1Application.html">Application</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classsymmetri_1_1Application.html" title="The Application class is a class that can create, configure and run a Petri net.">Application</a> class is a class that can create, configure and run a <a class="el" href="structsymmetri_1_1Petri.html" title="Petri is the class that holds the implementation of the Petri net. It holds pointers to the reducer q...">Petri</a> net.  <a href="classsymmetri_1_1Application.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsymmetri_1_1Event.html">Event</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct defines a subset of data that we associate with the result of firing a transition.  <a href="structsymmetri_1_1Event.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsymmetri_1_1Model.html">Model</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structsymmetri_1_1Model.html" title="Model is a different data structure to encode the Petri net. It is optimized for calculating the fire...">Model</a> is a different data structure to encode the <a class="el" href="structsymmetri_1_1Petri.html" title="Petri is the class that holds the implementation of the Petri net. It holds pointers to the reducer q...">Petri</a> net. It is optimized for calculating the fireable transitions and quick lookups in ordered vectors.  <a href="structsymmetri_1_1Model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsymmetri_1_1Petri.html">Petri</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structsymmetri_1_1Petri.html" title="Petri is the class that holds the implementation of the Petri net. It holds pointers to the reducer q...">Petri</a> is the class that holds the implementation of the <a class="el" href="structsymmetri_1_1Petri.html" title="Petri is the class that holds the implementation of the Petri net. It holds pointers to the reducer q...">Petri</a> net. It holds pointers to the reducer queue and that thread pool. Calling <code><a class="el" href="structsymmetri_1_1Petri.html#a3af89a04c50cf0b0458fb73587b16805" title="run the petri net. This initializes the net with the initial marking and blocks until it a) reached t...">run()</a></code> on this class will do the <em>actual</em> execution of the <a class="el" href="structsymmetri_1_1Petri.html" title="Petri is the class that holds the implementation of the Petri net. It holds pointers to the reducer q...">Petri</a> net.  <a href="structsymmetri_1_1Petri.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsymmetri_1_1PolyAction.html">PolyAction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsymmetri_1_1PolyAction.html" title="PolyAction is a wrapper around any type that you want to tie to a transition. Typically this is an in...">PolyAction</a> is a wrapper around any type that you want to tie to a transition. Typically this is an invokable object, such as a function, that executes some side-effects. The output of the invokable object can be used to communicate success or failure to the petri-net executor. You can create custom behavior by defining a tailored "fireTransition(const A&amp;)" for your transition payload.  <a href="classsymmetri_1_1PolyAction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsymmetri_1_1TaskQueue.html">TaskQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsymmetri_1_1TaskSystem.html">TaskSystem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The task system has a task queue for each thread. It is suggested to have one <a class="el" href="classsymmetri_1_1TaskSystem.html" title="The task system has a task queue for each thread. It is suggested to have one TaskSystem per executab...">TaskSystem</a> per executable and share it along the classes that use it. It uses a simply work-stealing mechanism for performance improvement.  <a href="classsymmetri_1_1TaskSystem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0b96d62146f8a25e1028447ca2fe77db"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesymmetri.html#a0b96d62146f8a25e1028447ca2fe77db">Store</a> = std::unordered_map&lt; Transition, <a class="el" href="classsymmetri_1_1PolyAction.html">PolyAction</a> &gt;</td></tr>
<tr class="memdesc:a0b96d62146f8a25e1028447ca2fe77db"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Store is a mapping from Transitions, represented by a string that is also used for their identification in the petri-net, to a PolyTask. A PolyTask may contain side-effects.  <br /></td></tr>
<tr class="separator:a0b96d62146f8a25e1028447ca2fe77db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181d179e36dbac2555bce020cd71157c"><td class="memItemLeft" align="right" valign="top"><a id="a181d179e36dbac2555bce020cd71157c" name="a181d179e36dbac2555bce020cd71157c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Place</b> = std::string</td></tr>
<tr class="separator:a181d179e36dbac2555bce020cd71157c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe8303eaca537c6edd9f8918f534a8a"><td class="memItemLeft" align="right" valign="top"><a id="a8fe8303eaca537c6edd9f8918f534a8a" name="a8fe8303eaca537c6edd9f8918f534a8a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Transition</b> = std::string</td></tr>
<tr class="separator:a8fe8303eaca537c6edd9f8918f534a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ab7524db7cb41e0643d2a762601668"><td class="memItemLeft" align="right" valign="top"><a id="a06ab7524db7cb41e0643d2a762601668" name="a06ab7524db7cb41e0643d2a762601668"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Clock</b> = std::chrono::steady_clock</td></tr>
<tr class="separator:a06ab7524db7cb41e0643d2a762601668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd7dcce5ab97a0890ab078f83435933"><td class="memItemLeft" align="right" valign="top"><a id="a3cd7dcce5ab97a0890ab078f83435933" name="a3cd7dcce5ab97a0890ab078f83435933"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Eventlog</b> = std::vector&lt; <a class="el" href="structsymmetri_1_1Event.html">Event</a> &gt;</td></tr>
<tr class="separator:a3cd7dcce5ab97a0890ab078f83435933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4126088671d92b088492a979e2fc269"><td class="memItemLeft" align="right" valign="top"><a id="aa4126088671d92b088492a979e2fc269" name="aa4126088671d92b088492a979e2fc269"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Result</b> = std::pair&lt; Eventlog, <a class="el" href="namespacesymmetri.html#ae147e58da807a85fe4e776557f3ddd7a">State</a> &gt;</td></tr>
<tr class="separator:aa4126088671d92b088492a979e2fc269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5260f5a518791717e194eb3f37caa656"><td class="memItemLeft" align="right" valign="top"><a id="a5260f5a518791717e194eb3f37caa656" name="a5260f5a518791717e194eb3f37caa656"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Net</b> = std::unordered_map&lt; Transition, std::pair&lt; std::vector&lt; Place &gt;, std::vector&lt; Place &gt; &gt; &gt;</td></tr>
<tr class="separator:a5260f5a518791717e194eb3f37caa656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4e9beabc165a0973a34974eba1c4cb"><td class="memItemLeft" align="right" valign="top"><a id="ace4e9beabc165a0973a34974eba1c4cb" name="ace4e9beabc165a0973a34974eba1c4cb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Marking</b> = std::unordered_map&lt; Place, uint16_t &gt;</td></tr>
<tr class="separator:ace4e9beabc165a0973a34974eba1c4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b6ac5e27222e448aa05c547d275a4e"><td class="memItemLeft" align="right" valign="top"><a id="a72b6ac5e27222e448aa05c547d275a4e" name="a72b6ac5e27222e448aa05c547d275a4e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PriorityTable</b> = std::vector&lt; std::pair&lt; Transition, int8_t &gt; &gt;</td></tr>
<tr class="separator:a72b6ac5e27222e448aa05c547d275a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6391ade94d5fe6e7d4d10249803b2186"><td class="memItemLeft" align="right" valign="top"><a id="a6391ade94d5fe6e7d4d10249803b2186" name="a6391ade94d5fe6e7d4d10249803b2186"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SmallVector</b> = gch::small_vector&lt; size_t, 4 &gt;</td></tr>
<tr class="separator:a6391ade94d5fe6e7d4d10249803b2186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a153fb9f52980c5a97a44aa65885df"><td class="memItemLeft" align="right" valign="top"><a id="a50a153fb9f52980c5a97a44aa65885df" name="a50a153fb9f52980c5a97a44aa65885df"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Reducer</b> = std::function&lt; <a class="el" href="structsymmetri_1_1Model.html">Model</a> &amp;(<a class="el" href="structsymmetri_1_1Model.html">Model</a> &amp;&amp;)&gt;</td></tr>
<tr class="separator:a50a153fb9f52980c5a97a44aa65885df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae147e58da807a85fe4e776557f3ddd7a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesymmetri.html#ae147e58da807a85fe4e776557f3ddd7a">State</a> { <br />
&#160;&#160;<a class="el" href="namespacesymmetri.html#ae147e58da807a85fe4e776557f3ddd7aa2b7dabba0077abe3732e0418b048a56b">Scheduled</a>
, <a class="el" href="namespacesymmetri.html#ae147e58da807a85fe4e776557f3ddd7aa8428552d86c0d262a542a528af490afa">Started</a>
, <a class="el" href="namespacesymmetri.html#ae147e58da807a85fe4e776557f3ddd7aa07ca5050e697392c9ed47e6453f1453f">Completed</a>
, <a class="el" href="namespacesymmetri.html#ae147e58da807a85fe4e776557f3ddd7aab5b078c00f1f60fe13c379ba56a7eb79">Deadlock</a>
, <br />
&#160;&#160;<a class="el" href="namespacesymmetri.html#ae147e58da807a85fe4e776557f3ddd7aa1a08e188c45a9dc17bf2eb94f6c1a42f">UserExit</a>
, <a class="el" href="namespacesymmetri.html#ae147e58da807a85fe4e776557f3ddd7aa902b0d55fddef6f8d651fe1035b7d4bd">Error</a>
<br />
 }</td></tr>
<tr class="memdesc:ae147e58da807a85fe4e776557f3ddd7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The difference kinds of results a transition can have.  <a href="namespacesymmetri.html#ae147e58da807a85fe4e776557f3ddd7a">More...</a><br /></td></tr>
<tr class="separator:ae147e58da807a85fe4e776557f3ddd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aaf296f6b2cd4b825fd7c384a65df0724"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; Net, Marking, PriorityTable &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesymmetri.html#aaf296f6b2cd4b825fd7c384a65df0724">readGrml</a> (const std::set&lt; std::string &gt; &amp;files)</td></tr>
<tr class="memdesc:aaf296f6b2cd4b825fd7c384a65df0724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of unique paths to grml-files, it parses and merges them, and returns <em>one</em> Net, initial marking and table containing transitions with their respective priority if it is not 1. If a place's initial marking is defined in multiple nets, the initial marking in the last processed net is used. Note that this is kind of random because a set orders the files.  <br /></td></tr>
<tr class="separator:aaf296f6b2cd4b825fd7c384a65df0724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06090b0b8a6aa53a4284b55469e86af"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; symmetri::Net, symmetri::Marking &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesymmetri.html#aa06090b0b8a6aa53a4284b55469e86af">readPnml</a> (const std::set&lt; std::string &gt; &amp;files)</td></tr>
<tr class="memdesc:aa06090b0b8a6aa53a4284b55469e86af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of unique paths to pnml-files, it parses and merges them, and returns <em>one</em> Net and initial marking. If the net has priorities, these will not be included in the net. If a place's initial marking is defined in multiple nets, the initial marking in the last processed net is used. Note that this is kind of random because a set orders the files.  <br /></td></tr>
<tr class="separator:aa06090b0b8a6aa53a4284b55469e86af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d32143fe0006093a26a831bb23b631"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2d32143fe0006093a26a831bb23b631"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesymmetri.html#ae2d32143fe0006093a26a831bb23b631">isDirectTransition</a> (const T &amp;)</td></tr>
<tr class="memdesc:ae2d32143fe0006093a26a831bb23b631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the transition-function can be invoked.  <br /></td></tr>
<tr class="separator:ae2d32143fe0006093a26a831bb23b631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467d3ae6e0d6478a9a59579e08f16e1c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a467d3ae6e0d6478a9a59579e08f16e1c"><td class="memTemplItemLeft" align="right" valign="top">Result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesymmetri.html#a467d3ae6e0d6478a9a59579e08f16e1c">cancelTransition</a> (const T &amp;)</td></tr>
<tr class="memdesc:a467d3ae6e0d6478a9a59579e08f16e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default cancel implementation is naive. It only returns a user-exit state and does nothing to the actual transition itself, and it will still complete. Its' reducer however is never processed.  <br /></td></tr>
<tr class="separator:a467d3ae6e0d6478a9a59579e08f16e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada47a258e8ae2ad89b78acd911a0cd42"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada47a258e8ae2ad89b78acd911a0cd42"><td class="memTemplItemLeft" align="right" valign="top">Result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesymmetri.html#ada47a258e8ae2ad89b78acd911a0cd42">fireTransition</a> (const T &amp;transition)</td></tr>
<tr class="memdesc:ada47a258e8ae2ad89b78acd911a0cd42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a Result based on what kind of information the transition-function returns.  <br /></td></tr>
<tr class="separator:ada47a258e8ae2ad89b78acd911a0cd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05989fac099a4cff8ca53560929c6762"><td class="memItemLeft" align="right" valign="top">Result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesymmetri.html#a05989fac099a4cff8ca53560929c6762">fireTransition</a> (const <a class="el" href="classsymmetri_1_1Application.html">Application</a> &amp;app)</td></tr>
<tr class="memdesc:a05989fac099a4cff8ca53560929c6762"><td class="mdescLeft">&#160;</td><td class="mdescRight">by defining a fireTransition for an <a class="el" href="classsymmetri_1_1Application.html" title="The Application class is a class that can create, configure and run a Petri net.">Application</a> type, we can also nest Applications as transitions in other nets.  <br /></td></tr>
<tr class="separator:a05989fac099a4cff8ca53560929c6762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226022f612dc84b7faaa4d394e374742"><td class="memItemLeft" align="right" valign="top">Result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesymmetri.html#a226022f612dc84b7faaa4d394e374742">cancelTransition</a> (const <a class="el" href="classsymmetri_1_1Application.html">Application</a> &amp;app)</td></tr>
<tr class="memdesc:a226022f612dc84b7faaa4d394e374742"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the <a class="el" href="structsymmetri_1_1Petri.html" title="Petri is the class that holds the implementation of the Petri net. It holds pointers to the reducer q...">Petri</a> net is nested, and its parent net tries to cancel the <a class="el" href="structsymmetri_1_1Petri.html" title="Petri is the class that holds the implementation of the Petri net. It holds pointers to the reducer q...">Petri</a> net, it calls exitEarly.  <br /></td></tr>
<tr class="separator:a226022f612dc84b7faaa4d394e374742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b12ab84f3390d6eb4d9788362ef6a8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesymmetri.html#a0b12ab84f3390d6eb4d9788362ef6a8a">isDirectTransition</a> (const <a class="el" href="classsymmetri_1_1Application.html">Application</a> &amp;)</td></tr>
<tr class="memdesc:a0b12ab84f3390d6eb4d9788362ef6a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">obviously a <a class="el" href="structsymmetri_1_1Petri.html" title="Petri is the class that holds the implementation of the Petri net. It holds pointers to the reducer q...">Petri</a> net is not a direct-transition  <br /></td></tr>
<tr class="separator:a0b12ab84f3390d6eb4d9788362ef6a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663f9de17f04a2b8e0d290e47e1dc92d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a663f9de17f04a2b8e0d290e47e1dc92d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesymmetri.html#a663f9de17f04a2b8e0d290e47e1dc92d">MarkingEquality</a> (const std::vector&lt; T &gt; &amp;m1, const std::vector&lt; T &gt; &amp;m2)</td></tr>
<tr class="memdesc:a663f9de17f04a2b8e0d290e47e1dc92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the markings are exactly the same. Note that this uses a different type for Marking compared to the Marking type used to construct a net (an unordered map of strings). In this format the amount of tokens in a particular place is represented by how often that place occurs in the vector. For example: {"A","A","B"} is a marking with two tokens in place "A" and one token in place "B". This format does not have the overhead of mentioning all empty places.  <br /></td></tr>
<tr class="separator:a663f9de17f04a2b8e0d290e47e1dc92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418009feff8440061b68e708f273021b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a418009feff8440061b68e708f273021b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesymmetri.html#a418009feff8440061b68e708f273021b">MarkingReached</a> (const std::vector&lt; T &gt; &amp;marking, const std::vector&lt; T &gt; &amp;final_marking)</td></tr>
<tr class="memdesc:a418009feff8440061b68e708f273021b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if marking is at least a subset of final_marking. Note that this uses a different type for Marking compared to the Marking type used to construct a net (an unordered map of strings). In this format the amount of tokens in a particular place is represented by how often that place occurs in the vector. For example: {"A","A","B"} is a marking with two tokens in place "A" and one token in place "B". This format does not have the overhead of mentioning all empty places.  <br /></td></tr>
<tr class="separator:a418009feff8440061b68e708f273021b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c2cf03e783cd4bca9d7ba72dec6835"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesymmetri.html#a08c2cf03e783cd4bca9d7ba72dec6835">stateNetEquality</a> (const Net &amp;net1, const Net &amp;net2)</td></tr>
<tr class="memdesc:a08c2cf03e783cd4bca9d7ba72dec6835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two petri-nets have equal amount of arcs between places and transitions of the same name.  <br /></td></tr>
<tr class="separator:a08c2cf03e783cd4bca9d7ba72dec6835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fab87c1ec65a55db8fb5b2126a8c14a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesymmetri.html#a6fab87c1ec65a55db8fb5b2126a8c14a">calculateTrace</a> (const Eventlog &amp;event_log) noexcept</td></tr>
<tr class="memdesc:a6fab87c1ec65a55db8fb5b2126a8c14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash given an event log. This hash is only influenced by the order of the completions of transitions and if the output of those transitions is Completed, or something else.  <br /></td></tr>
<tr class="separator:a6fab87c1ec65a55db8fb5b2126a8c14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4668cbae76d223cb2eef823c6667e8b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesymmetri.html#ab4668cbae76d223cb2eef823c6667e8b">printState</a> (<a class="el" href="namespacesymmetri.html#ae147e58da807a85fe4e776557f3ddd7a">State</a> s) noexcept</td></tr>
<tr class="memdesc:ab4668cbae76d223cb2eef823c6667e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function to get a string representation of the state-enum.  <br /></td></tr>
<tr class="separator:ab4668cbae76d223cb2eef823c6667e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d3080d054ce5cc3c3fda3ba80d0177"><td class="memItemLeft" align="right" valign="top"><a id="ab7d3080d054ce5cc3c3fda3ba80d0177" name="ab7d3080d054ce5cc3c3fda3ba80d0177"></a>
std::tuple&lt; std::vector&lt; Transition &gt;, std::vector&lt; Place &gt;, std::vector&lt; <a class="el" href="classsymmetri_1_1PolyAction.html">PolyAction</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>convert</b> (const Net &amp;_net, const <a class="el" href="namespacesymmetri.html#a0b96d62146f8a25e1028447ca2fe77db">Store</a> &amp;_store)</td></tr>
<tr class="separator:ab7d3080d054ce5cc3c3fda3ba80d0177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3b3b4749fa36c8a9052cf240372a50"><td class="memItemLeft" align="right" valign="top"><a id="a0f3b3b4749fa36c8a9052cf240372a50" name="a0f3b3b4749fa36c8a9052cf240372a50"></a>
std::tuple&lt; std::vector&lt; symmetri::SmallVector &gt;, std::vector&lt; symmetri::SmallVector &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>populateIoLookups</b> (const Net &amp;_net, const std::vector&lt; Place &gt; &amp;ordered_places)</td></tr>
<tr class="separator:a0f3b3b4749fa36c8a9052cf240372a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064d1232483280a5c361156f5d301c06"><td class="memItemLeft" align="right" valign="top"><a id="a064d1232483280a5c361156f5d301c06" name="a064d1232483280a5c361156f5d301c06"></a>
std::vector&lt; symmetri::SmallVector &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>createReversePlaceToTransitionLookup</b> (size_t place_count, size_t transition_count, const std::vector&lt; symmetri::SmallVector &gt; &amp;input_transitions)</td></tr>
<tr class="separator:a064d1232483280a5c361156f5d301c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e1ae789075ce077d028c031e20c5e5"><td class="memItemLeft" align="right" valign="top"><a id="a52e1ae789075ce077d028c031e20c5e5" name="a52e1ae789075ce077d028c031e20c5e5"></a>
std::vector&lt; int8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>createPriorityLookup</b> (const std::vector&lt; Transition &gt; transition, const PriorityTable &amp;_priority)</td></tr>
<tr class="separator:a52e1ae789075ce077d028c031e20c5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5def1daa631f8fae536487ba1e09da"><td class="memItemLeft" align="right" valign="top"><a id="acf5def1daa631f8fae536487ba1e09da" name="acf5def1daa631f8fae536487ba1e09da"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>toIndex</b> (const std::vector&lt; std::string &gt; &amp;m, const std::string &amp;s)</td></tr>
<tr class="separator:acf5def1daa631f8fae536487ba1e09da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6441c5607b5880645b02f69afd3ce9a3"><td class="memItemLeft" align="right" valign="top"><a id="a6441c5607b5880645b02f69afd3ce9a3" name="a6441c5607b5880645b02f69afd3ce9a3"></a>
gch::small_vector&lt; uint8_t, 32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>possibleTransitions</b> (const std::vector&lt; size_t &gt; &amp;tokens, const std::vector&lt; SmallVector &gt; &amp;p_to_ts_n, const std::vector&lt; int8_t &gt; &amp;priorities)</td></tr>
<tr class="separator:a6441c5607b5880645b02f69afd3ce9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17572a7d94465cbc63f603207aa2bd10"><td class="memItemLeft" align="right" valign="top"><a id="a17572a7d94465cbc63f603207aa2bd10" name="a17572a7d94465cbc63f603207aa2bd10"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>canFire</b> (const SmallVector &amp;pre, const std::vector&lt; size_t &gt; &amp;tokens)</td></tr>
<tr class="separator:a17572a7d94465cbc63f603207aa2bd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afccd1e519e8607aff3011408f1d345"><td class="memItemLeft" align="right" valign="top"><a id="a3afccd1e519e8607aff3011408f1d345" name="a3afccd1e519e8607aff3011408f1d345"></a>
Reducer&#160;</td><td class="memItemRight" valign="bottom"><b>createReducerForTransition</b> (size_t T_i, const <a class="el" href="classsymmetri_1_1PolyAction.html">PolyAction</a> &amp;task, const std::string &amp;case_id, const std::shared_ptr&lt; moodycamel::BlockingConcurrentQueue&lt; Reducer &gt; &gt; &amp;reducers)</td></tr>
<tr class="separator:a3afccd1e519e8607aff3011408f1d345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f7a2e7ce12085c6804b78a2e4d7e30"><td class="memItemLeft" align="right" valign="top"><a id="ac0f7a2e7ce12085c6804b78a2e4d7e30" name="ac0f7a2e7ce12085c6804b78a2e4d7e30"></a>
Reducer&#160;</td><td class="memItemRight" valign="bottom"><b>processTransition</b> (size_t t_i, const std::string &amp;case_id, <a class="el" href="namespacesymmetri.html#ae147e58da807a85fe4e776557f3ddd7a">State</a> result, Clock::time_point end_time)</td></tr>
<tr class="separator:ac0f7a2e7ce12085c6804b78a2e4d7e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfba33a1c71b27511b05cdbc521dbeb"><td class="memItemLeft" align="right" valign="top"><a id="a2cfba33a1c71b27511b05cdbc521dbeb" name="a2cfba33a1c71b27511b05cdbc521dbeb"></a>
Reducer&#160;</td><td class="memItemRight" valign="bottom"><b>processTransition</b> (size_t t_i, const Eventlog &amp;new_events, <a class="el" href="namespacesymmetri.html#ae147e58da807a85fe4e776557f3ddd7a">State</a> result)</td></tr>
<tr class="separator:a2cfba33a1c71b27511b05cdbc521dbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1575a6055664577d0d4574b81ff44a7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesymmetri.html#ae1575a6055664577d0d4574b81ff44a7">getThreadId</a> ()</td></tr>
<tr class="memdesc:ae1575a6055664577d0d4574b81ff44a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Thread Id object. We go to "great lengths" to get a 32 bit representation of the thread id, because in that case the atomic is lock-free on (most) 64 bit systems.  <br /></td></tr>
<tr class="separator:ae1575a6055664577d0d4574b81ff44a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca35631a769e14692ff48ba27b9c84c4"><td class="memItemLeft" align="right" valign="top"><a id="aca35631a769e14692ff48ba27b9c84c4" name="aca35631a769e14692ff48ba27b9c84c4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>areAllTransitionsInStore</b> (const <a class="el" href="namespacesymmetri.html#a0b96d62146f8a25e1028447ca2fe77db">Store</a> &amp;store, const Net &amp;net) noexcept</td></tr>
<tr class="separator:aca35631a769e14692ff48ba27b9c84c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491cb1edad4b611d2d1f7e968e6478f1"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::shared_ptr&lt; <a class="el" href="structsymmetri_1_1Petri.html">Petri</a> &gt;, std::function&lt; void(const Transition &amp;)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesymmetri.html#a491cb1edad4b611d2d1f7e968e6478f1">create</a> (const Net &amp;net, const Marking &amp;m0, const Marking &amp;final_marking, const <a class="el" href="namespacesymmetri.html#a0b96d62146f8a25e1028447ca2fe77db">Store</a> &amp;store, const PriorityTable &amp;priority, const std::string &amp;case_id, std::shared_ptr&lt; <a class="el" href="classsymmetri_1_1TaskSystem.html">TaskSystem</a> &gt; stp)</td></tr>
<tr class="memdesc:a491cb1edad4b611d2d1f7e968e6478f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory function that creates a <a class="el" href="structsymmetri_1_1Petri.html" title="Petri is the class that holds the implementation of the Petri net. It holds pointers to the reducer q...">Petri</a> and a handler that allows to register triggers to functions.  <br /></td></tr>
<tr class="separator:a491cb1edad4b611d2d1f7e968e6478f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3311135c7c7eab1d270098b740d69342"><td class="memItemLeft" align="right" valign="top"><a id="a3311135c7c7eab1d270098b740d69342" name="a3311135c7c7eab1d270098b740d69342"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3311135c7c7eab1d270098b740d69342"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MarkingEquality&lt; size_t &gt;</b> (const std::vector&lt; size_t &gt; &amp;m1, const std::vector&lt; size_t &gt; &amp;m2)</td></tr>
<tr class="separator:a3311135c7c7eab1d270098b740d69342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb70142416ff52fd1f876f37035e0b1e"><td class="memItemLeft" align="right" valign="top"><a id="acb70142416ff52fd1f876f37035e0b1e" name="acb70142416ff52fd1f876f37035e0b1e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:acb70142416ff52fd1f876f37035e0b1e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MarkingReached&lt; size_t &gt;</b> (const std::vector&lt; size_t &gt; &amp;marking, const std::vector&lt; size_t &gt; &amp;final_marking)</td></tr>
<tr class="separator:acb70142416ff52fd1f876f37035e0b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ad32c5f70c38be1929c4db68d07132"><td class="memItemLeft" align="right" valign="top"><a id="a51ad32c5f70c38be1929c4db68d07132" name="a51ad32c5f70c38be1929c4db68d07132"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a51ad32c5f70c38be1929c4db68d07132"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MarkingEquality&lt; std::string &gt;</b> (const std::vector&lt; std::string &gt; &amp;m1, const std::vector&lt; std::string &gt; &amp;m2)</td></tr>
<tr class="separator:a51ad32c5f70c38be1929c4db68d07132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6828da1a8416373259b16cf20213bb62"><td class="memItemLeft" align="right" valign="top"><a id="a6828da1a8416373259b16cf20213bb62" name="a6828da1a8416373259b16cf20213bb62"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6828da1a8416373259b16cf20213bb62"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MarkingReached&lt; std::string &gt;</b> (const std::vector&lt; std::string &gt; &amp;marking, const std::vector&lt; std::string &gt; &amp;final_marking)</td></tr>
<tr class="separator:a6828da1a8416373259b16cf20213bb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae59d9293ece5cbec23d776fac4b1c154"><td class="memItemLeft" align="right" valign="top"><a id="ae59d9293ece5cbec23d776fac4b1c154" name="ae59d9293ece5cbec23d776fac4b1c154"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>NumRounds</b> = 4</td></tr>
<tr class="separator:ae59d9293ece5cbec23d776fac4b1c154"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The implementation is based on Sean Parent's task system, described in, Better Code: Concurrency. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a0b96d62146f8a25e1028447ca2fe77db" name="a0b96d62146f8a25e1028447ca2fe77db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b96d62146f8a25e1028447ca2fe77db">&#9670;&#160;</a></span>Store</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::unordered_map&lt; Transition, <a class="el" href="classsymmetri_1_1PolyAction.html">PolyAction</a> &gt; <a class="el" href="namespacesymmetri.html#a0b96d62146f8a25e1028447ca2fe77db">symmetri::Store</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Store is a mapping from Transitions, represented by a string that is also used for their identification in the petri-net, to a PolyTask. A PolyTask may contain side-effects. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ae147e58da807a85fe4e776557f3ddd7a" name="ae147e58da807a85fe4e776557f3ddd7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae147e58da807a85fe4e776557f3ddd7a">&#9670;&#160;</a></span>State</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacesymmetri.html#ae147e58da807a85fe4e776557f3ddd7a">symmetri::State</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The difference kinds of results a transition can have. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae147e58da807a85fe4e776557f3ddd7aa2b7dabba0077abe3732e0418b048a56b" name="ae147e58da807a85fe4e776557f3ddd7aa2b7dabba0077abe3732e0418b048a56b"></a>Scheduled&#160;</td><td class="fielddoc"><p>The transition is put into the task system. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae147e58da807a85fe4e776557f3ddd7aa8428552d86c0d262a542a528af490afa" name="ae147e58da807a85fe4e776557f3ddd7aa8428552d86c0d262a542a528af490afa"></a>Started&#160;</td><td class="fielddoc"><p>The transition started. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae147e58da807a85fe4e776557f3ddd7aa07ca5050e697392c9ed47e6453f1453f" name="ae147e58da807a85fe4e776557f3ddd7aa07ca5050e697392c9ed47e6453f1453f"></a>Completed&#160;</td><td class="fielddoc"><p>The transition completed as expected. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae147e58da807a85fe4e776557f3ddd7aab5b078c00f1f60fe13c379ba56a7eb79" name="ae147e58da807a85fe4e776557f3ddd7aab5b078c00f1f60fe13c379ba56a7eb79"></a>Deadlock&#160;</td><td class="fielddoc"><p>The transition deadlocked (applies to petri nets) </p>
</td></tr>
<tr><td class="fieldname"><a id="ae147e58da807a85fe4e776557f3ddd7aa1a08e188c45a9dc17bf2eb94f6c1a42f" name="ae147e58da807a85fe4e776557f3ddd7aa1a08e188c45a9dc17bf2eb94f6c1a42f"></a>UserExit&#160;</td><td class="fielddoc"><p>The transition or interrupted and possibly stopped. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae147e58da807a85fe4e776557f3ddd7aa902b0d55fddef6f8d651fe1035b7d4bd" name="ae147e58da807a85fe4e776557f3ddd7aa902b0d55fddef6f8d651fe1035b7d4bd"></a>Error&#160;</td><td class="fielddoc"><p>None of the above. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6fab87c1ec65a55db8fb5b2126a8c14a" name="a6fab87c1ec65a55db8fb5b2126a8c14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fab87c1ec65a55db8fb5b2126a8c14a">&#9670;&#160;</a></span>calculateTrace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t symmetri::calculateTrace </td>
          <td>(</td>
          <td class="paramtype">const Eventlog &amp;&#160;</td>
          <td class="paramname"><em>event_log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash given an event log. This hash is only influenced by the order of the completions of transitions and if the output of those transitions is Completed, or something else. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_log</td><td>An eventlog, can both be from a terminated or a still active net. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The hashed result. </dd></dl>

</div>
</div>
<a id="a226022f612dc84b7faaa4d394e374742" name="a226022f612dc84b7faaa4d394e374742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226022f612dc84b7faaa4d394e374742">&#9670;&#160;</a></span>cancelTransition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Result symmetri::cancelTransition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsymmetri_1_1Application.html">Application</a> &amp;&#160;</td>
          <td class="paramname"><em>app</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>if the <a class="el" href="structsymmetri_1_1Petri.html" title="Petri is the class that holds the implementation of the Petri net. It holds pointers to the reducer q...">Petri</a> net is nested, and its parent net tries to cancel the <a class="el" href="structsymmetri_1_1Petri.html" title="Petri is the class that holds the implementation of the Petri net. It holds pointers to the reducer q...">Petri</a> net, it calls exitEarly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">app</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result </dd></dl>

</div>
</div>
<a id="a467d3ae6e0d6478a9a59579e08f16e1c" name="a467d3ae6e0d6478a9a59579e08f16e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467d3ae6e0d6478a9a59579e08f16e1c">&#9670;&#160;</a></span>cancelTransition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Result symmetri::cancelTransition </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default cancel implementation is naive. It only returns a user-exit state and does nothing to the actual transition itself, and it will still complete. Its' reducer however is never processed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result </dd></dl>

</div>
</div>
<a id="a491cb1edad4b611d2d1f7e968e6478f1" name="a491cb1edad4b611d2d1f7e968e6478f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491cb1edad4b611d2d1f7e968e6478f1">&#9670;&#160;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::shared_ptr&lt; <a class="el" href="structsymmetri_1_1Petri.html">Petri</a> &gt;, std::function&lt; void(const Transition &amp;)&gt; &gt; symmetri::create </td>
          <td>(</td>
          <td class="paramtype">const Net &amp;&#160;</td>
          <td class="paramname"><em>net</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Marking &amp;&#160;</td>
          <td class="paramname"><em>m0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Marking &amp;&#160;</td>
          <td class="paramname"><em>final_marking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesymmetri.html#a0b96d62146f8a25e1028447ca2fe77db">Store</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PriorityTable &amp;&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>case_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classsymmetri_1_1TaskSystem.html">TaskSystem</a> &gt;&#160;</td>
          <td class="paramname"><em>stp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A factory function that creates a <a class="el" href="structsymmetri_1_1Petri.html" title="Petri is the class that holds the implementation of the Petri net. It holds pointers to the reducer q...">Petri</a> and a handler that allows to register triggers to functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">net</td><td></td></tr>
    <tr><td class="paramname">m0</td><td></td></tr>
    <tr><td class="paramname">final_marking</td><td></td></tr>
    <tr><td class="paramname">store</td><td></td></tr>
    <tr><td class="paramname">priority</td><td></td></tr>
    <tr><td class="paramname">case_id</td><td></td></tr>
    <tr><td class="paramname">stp</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;std::shared_ptr&lt;Petri&gt;, std::function&lt;void(const
Transition &amp;)&gt;&gt; </dd></dl>

</div>
</div>
<a id="a05989fac099a4cff8ca53560929c6762" name="a05989fac099a4cff8ca53560929c6762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05989fac099a4cff8ca53560929c6762">&#9670;&#160;</a></span>fireTransition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Result symmetri::fireTransition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsymmetri_1_1Application.html">Application</a> &amp;&#160;</td>
          <td class="paramname"><em>app</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>by defining a fireTransition for an <a class="el" href="classsymmetri_1_1Application.html" title="The Application class is a class that can create, configure and run a Petri net.">Application</a> type, we can also nest Applications as transitions in other nets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">app</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result </dd></dl>

</div>
</div>
<a id="ada47a258e8ae2ad89b78acd911a0cd42" name="ada47a258e8ae2ad89b78acd911a0cd42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada47a258e8ae2ad89b78acd911a0cd42">&#9670;&#160;</a></span>fireTransition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Result symmetri::fireTransition </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>transition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a Result based on what kind of information the transition-function returns. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The transition-function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transition</td><td>The function to be executed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result Contains information on the result-state and possible eventlog of the transition. </dd></dl>

</div>
</div>
<a id="ae1575a6055664577d0d4574b81ff44a7" name="ae1575a6055664577d0d4574b81ff44a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1575a6055664577d0d4574b81ff44a7">&#9670;&#160;</a></span>getThreadId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int symmetri::getThreadId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Thread Id object. We go to "great lengths" to get a 32 bit representation of the thread id, because in that case the atomic is lock-free on (most) 64 bit systems. </p>
<dl class="section return"><dt>Returns</dt><dd>unsigned int </dd></dl>

</div>
</div>
<a id="a0b12ab84f3390d6eb4d9788362ef6a8a" name="a0b12ab84f3390d6eb4d9788362ef6a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b12ab84f3390d6eb4d9788362ef6a8a">&#9670;&#160;</a></span>isDirectTransition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool symmetri::isDirectTransition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsymmetri_1_1Application.html">Application</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>obviously a <a class="el" href="structsymmetri_1_1Petri.html" title="Petri is the class that holds the implementation of the Petri net. It holds pointers to the reducer q...">Petri</a> net is not a direct-transition </p>
<dl class="section return"><dt>Returns</dt><dd>true </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="ae2d32143fe0006093a26a831bb23b631" name="ae2d32143fe0006093a26a831bb23b631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d32143fe0006093a26a831bb23b631">&#9670;&#160;</a></span>isDirectTransition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool symmetri::isDirectTransition </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the transition-function can be invoked. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the transition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The pre- and post-marking-mutation can happen instantly. </dd>
<dd>
false The pre-marking mutation happens instantly and the post-marking-mutation should only happen after the transition is invoked. </dd></dl>

</div>
</div>
<a id="a663f9de17f04a2b8e0d290e47e1dc92d" name="a663f9de17f04a2b8e0d290e47e1dc92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663f9de17f04a2b8e0d290e47e1dc92d">&#9670;&#160;</a></span>MarkingEquality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool symmetri::MarkingEquality </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the markings are exactly the same. Note that this uses a different type for Marking compared to the Marking type used to construct a net (an unordered map of strings). In this format the amount of tokens in a particular place is represented by how often that place occurs in the vector. For example: {"A","A","B"} is a marking with two tokens in place "A" and one token in place "B". This format does not have the overhead of mentioning all empty places. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td></td></tr>
    <tr><td class="paramname">m2</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="a418009feff8440061b68e708f273021b" name="a418009feff8440061b68e708f273021b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418009feff8440061b68e708f273021b">&#9670;&#160;</a></span>MarkingReached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool symmetri::MarkingReached </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>marking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>final_marking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if marking is at least a subset of final_marking. Note that this uses a different type for Marking compared to the Marking type used to construct a net (an unordered map of strings). In this format the amount of tokens in a particular place is represented by how often that place occurs in the vector. For example: {"A","A","B"} is a marking with two tokens in place "A" and one token in place "B". This format does not have the overhead of mentioning all empty places. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">marking</td><td></td></tr>
    <tr><td class="paramname">final_marking</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="ab4668cbae76d223cb2eef823c6667e8b" name="ab4668cbae76d223cb2eef823c6667e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4668cbae76d223cb2eef823c6667e8b">&#9670;&#160;</a></span>printState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string symmetri::printState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesymmetri.html#ae147e58da807a85fe4e776557f3ddd7a">symmetri::State</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A convenience function to get a string representation of the state-enum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The State </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string The State as a human readable string. </dd></dl>

</div>
</div>
<a id="aaf296f6b2cd4b825fd7c384a65df0724" name="aaf296f6b2cd4b825fd7c384a65df0724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf296f6b2cd4b825fd7c384a65df0724">&#9670;&#160;</a></span>readGrml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; symmetri::Net, symmetri::Marking, symmetri::PriorityTable &gt; symmetri::readGrml </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>files</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of unique paths to grml-files, it parses and merges them, and returns <em>one</em> Net, initial marking and table containing transitions with their respective priority if it is not 1. If a place's initial marking is defined in multiple nets, the initial marking in the last processed net is used. Note that this is kind of random because a set orders the files. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grml-files</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;symmetri::Net, symmetri::Marking,symmetri::PriorityTable&gt; </dd></dl>

</div>
</div>
<a id="aa06090b0b8a6aa53a4284b55469e86af" name="aa06090b0b8a6aa53a4284b55469e86af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06090b0b8a6aa53a4284b55469e86af">&#9670;&#160;</a></span>readPnml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; Net, Marking &gt; symmetri::readPnml </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>files</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of unique paths to pnml-files, it parses and merges them, and returns <em>one</em> Net and initial marking. If the net has priorities, these will not be included in the net. If a place's initial marking is defined in multiple nets, the initial marking in the last processed net is used. Note that this is kind of random because a set orders the files. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">files</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;symmetri::Net, symmetri::Marking&gt; </dd></dl>

</div>
</div>
<a id="a08c2cf03e783cd4bca9d7ba72dec6835" name="a08c2cf03e783cd4bca9d7ba72dec6835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c2cf03e783cd4bca9d7ba72dec6835">&#9670;&#160;</a></span>stateNetEquality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool symmetri::stateNetEquality </td>
          <td>(</td>
          <td class="paramtype">const Net &amp;&#160;</td>
          <td class="paramname"><em>net1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Net &amp;&#160;</td>
          <td class="paramname"><em>net2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if two petri-nets have equal amount of arcs between places and transitions of the same name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">net1</td><td></td></tr>
    <tr><td class="paramname">net2</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true </dd>
<dd>
false </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
